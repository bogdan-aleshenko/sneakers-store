
# Performance Profiling Report

## 1. Вибір інструментів

Для профілювання PHP-застосунку були використані наступні інструменти:

- **Xdebug**: для збору інформації про час виконання функцій.
- **QCacheGrind**: для візуального аналізу `cachegrind.out` файлів.
- **Visual Studio Code + PHP Debug**: для загального профілювання та перегляду коду.

## 2. Ключові метрики продуктивності

Було вирішено відстежувати такі метрики:

- Час виконання функцій (CPU time)
- Кількість викликів функцій
- Навантаження на БД (через виклики `PDO::prepare` та `PDO::execute`)

## 3. Тестові сценарії

- Відкриття головної сторінки магазину (index.php)
- Завантаження списку товарів з БД (виклик `getSneakersFromDB()`)

## 4. Початкове профілювання

### Гарячі точки до оптимізації:

- `getSneakersFromDB()` — 49.6% від загального часу
- `PDOStatement::execute` — значна частка часу
- `include::index.php` — основна точка входу

Було виявлено, що SQL-запит у `getSneakersFromDB()` неефективний.

## 5. Оптимізація

Оптимізований код `getSneakersFromDB()`:

- Зменшено кількість полів у SQL-запиті
- Додано індекси до полів у таблиці
- Уникнуто зайвого fetch у циклі

## 6. Повторне профілювання

### Гарячі точки після оптимізації:

- `getSneakersFromDB()` **більше не входить до топ-функцій за споживанням часу**
- Основне навантаження — `Composer\Autoload\ClassLoader`, `require_once`

Це свідчить, що продуктивність основної логіки значно покращилась.

## 7. Порівняння результатів

| Метрика | До оптимізації | Після оптимізації |
|--------|----------------|-------------------|
| `getSneakersFromDB()` | ~49% | <5% |
| `PDOStatement::execute` | значне навантаження | мінімальне |
| Загальний час | високий | значно нижчий |

## 8. Висновки

- Виявлені гарячі точки були успішно оптимізовані.
- Значно зменшено час виконання запитів до БД.
- Після оптимізації залишились лише базові системні витрати.

---

**Файл профілю:** `cachegrind.out.21408`
